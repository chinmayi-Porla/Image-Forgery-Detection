import tkinter as tk
from tkinter import filedialog, messagebox, ttk
from PIL import Image, ImageTk
import numpy as np
import os
import joblib
import matplotlib.pyplot as plt
import cv2
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, roc_curve, auc, confusion_matrix
from sklearn.metrics.pairwise import cosine_similarity

# Constants for styling
BG_COLOR = '#f4f6fa'
ACCENT_COLOR = '#2d7ff9'
HEADER_COLOR = '#1a2233'
PANEL_BG = '#ffffff'
BORDER_COLOR = '#e0e0e0'
FONT = ('Segoe UI', 11)
HEADER_FONT = ('Segoe UI', 16, 'bold')
TITLE_FONT = ('Segoe UI', 22, 'bold')

class DeepFakeAnalyzerGUI:
    def __init__(self, root, preprocessor, feature_extractor):
        self.root = root
        self.root.title('Image Forgery Detection')
        self.root.geometry('1200x700')
        self.root.configure(bg=BG_COLOR)
        
        # Initialize variables
        self.selected_image_path = None
        self.selected_image = None
        self.analysis_result = None
        self.confidence = None
        self.similarity = None
        self.reference_image = None
        self.current_analysis_results = None
        
        self.preprocessor = preprocessor
        self.feature_extractor = feature_extractor

        # Load models and data. These will be generated by main.py if not found.
        try:
            self.fusion_model = joblib.load('fusion_xgboost_model.pkl')
            self.baseline_model = joblib.load('baseline_sift_xgboost_model.pkl')
            self.X_test_fusion = np.load('X_test_fusion.npy')
            self.y_test = np.load('y_test.npy')
            self.mean_features_real = np.load('mean_features_real.npy')
            self.mean_features_fake = np.load('mean_features_fake.npy')
        except FileNotFoundError:
            messagebox.showerror("Error", "Model or data files not found. Please run main.py once to generate dummy files, or train your own models.")
            # Create dummy attributes to prevent errors if files are missing
            from xgboost import XGBClassifier
            self.fusion_model = XGBClassifier()
            self.baseline_model = XGBClassifier()
            self.X_test_fusion = np.random.rand(10, 128 + 1024 + 2048 + 512)
            self.y_test = np.random.randint(0, 2, 10)
            self.mean_features_real = np.random.rand(128 + 1024 + 2048 + 512)
            self.mean_features_fake = np.random.rand(128 + 1024 + 2048 + 512)

        # Initialize components
        self.setup_styles()
        self.setup_gui()
    
    def setup_styles(self):
        """Configure ttk styles"""
        style = ttk.Style()
        style.theme_use('clam')
        style.configure('TNotebook', background=BG_COLOR, borderwidth=0)
        style.configure('TNotebook.Tab', font=HEADER_FONT, padding=[20, 10], 
                       background=BG_COLOR, foreground=HEADER_COLOR)
        style.map('TNotebook.Tab', 
                 background=[('selected', ACCENT_COLOR)], 
                 foreground=[('selected', 'white')])
        style.configure('Treeview', font=FONT, rowheight=28, 
                       fieldbackground=PANEL_BG, background=PANEL_BG)
        style.configure('Treeview.Heading', font=HEADER_FONT, 
                       background=ACCENT_COLOR, foreground='white')
    
    def setup_gui(self):
        """Setup the main GUI layout"""
        # Create main container
        self.main_container = ttk.Frame(self.root)
        self.main_container.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        # Create notebook for tabs
        self.notebook = ttk.Notebook(self.main_container)
        self.notebook.pack(fill=tk.BOTH, expand=True)
        
        # Create tabs
        self.analysis_tab = ttk.Frame(self.notebook)
        self.performance_tab = ttk.Frame(self.notebook)
        
        self.notebook.add(self.analysis_tab, text='Image Analysis')
        self.notebook.add(self.performance_tab, text='Model Performance')
        
        # Setup each tab
        self.setup_analysis_tab()
        self.setup_performance_tab()
    
    def setup_analysis_tab(self):
        """Setup the analysis tab"""
        main_frame = ttk.Frame(self.analysis_tab)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Left panel
        left_panel = ttk.Frame(main_frame)
        left_panel.pack(side=tk.LEFT, fill=tk.Y, padx=10, pady=10)
        
        # Browse button
        browse_btn = ttk.Button(left_panel, text="Browse Image", command=self.select_image)
        browse_btn.pack(fill=tk.X, pady=10)
        
        # Image preview
        preview_frame = ttk.LabelFrame(left_panel, text='Selected Image Preview:')
        preview_frame.pack(fill=tk.BOTH, expand=False, pady=5)
        self.image_preview = ttk.Label(preview_frame)
        self.image_preview.pack()
        self.image_name_label = ttk.Label(preview_frame, text='')
        self.image_name_label.pack()
        
        # Analysis results
        results_frame = ttk.LabelFrame(left_panel, text='Analysis Results:')
        results_frame.pack(fill=tk.BOTH, expand=True, pady=5)
        self.results_text = tk.Text(results_frame, height=12, width=35, font=FONT)
        self.results_text.pack(fill=tk.BOTH, expand=True)
        self.results_text.config(state=tk.DISABLED)
        
        # Right panel
        right_panel = ttk.Frame(main_frame)
        right_panel.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=10, pady=10)
        ttk.Label(right_panel, text='Image Analysis Visualization', font=HEADER_FONT, foreground=ACCENT_COLOR).pack(anchor=tk.W, pady=5)
        viz_frame = ttk.Frame(right_panel)
        viz_frame.pack(fill=tk.BOTH, expand=True)
        
        # 2x2 grid for visualizations
        self.viz_labels = []
        self.viz_canvases = []
        for i, title in enumerate([f'Original', 'Preprocessed Image', 'Color Histogram', 'Edge Detection']):
            frame = ttk.LabelFrame(viz_frame, text=title)
            frame.grid(row=i//2, column=i%2, padx=10, pady=10, sticky='nsew')
            label = ttk.Label(frame)
            label.pack()
            self.viz_labels.append(label)
            self.viz_canvases.append(frame)
        viz_frame.grid_rowconfigure(0, weight=1)
        viz_frame.grid_rowconfigure(1, weight=1)
        viz_frame.grid_columnconfigure(0, weight=1)
        viz_frame.grid_columnconfigure(1, weight=1)
    
    def setup_performance_tab(self):
        perf_main = ttk.Frame(self.performance_tab)
        perf_main.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        # Left side: Table + ROC
        left_perf = ttk.Frame(perf_main)
        left_perf.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=10)
        # Performance Table
        table_frame = ttk.LabelFrame(left_perf, text='Performance Table (SIFT+DeepFeat+GAN)')
        table_frame.pack(fill=tk.X, pady=10)
        columns = ('Model', 'Accuracy', 'Precision', 'Recall', 'F1 Score')
        self.perf_table = ttk.Treeview(table_frame, columns=columns, show='headings', height=3)
        for col in columns:
            self.perf_table.heading(col, text=col)
            self.perf_table.column(col, width=100, anchor=tk.CENTER)
        self.perf_table.pack(fill=tk.X)
        # ROC Curve
        roc_frame = ttk.LabelFrame(left_perf, text='ROC Curve')
        roc_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        # Right side: Confusion Matrices
        right_perf = ttk.Frame(perf_main)
        right_perf.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=10)
        # Fusion Model Confusion Matrix
        cm_fusion_frame = ttk.LabelFrame(right_perf, text='Confusion Matrix: Fusion (SIFT+DeepFeat+GAN)')
        cm_fusion_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        # Baseline Confusion Matrix
        cm_base_frame = ttk.LabelFrame(right_perf, text='Confusion Matrix: Baseline (SIFT Only)')
        cm_base_frame.pack(fill=tk.BOTH, expand=True, pady=10)

        # Calculate metrics for Fusion model
        y_pred_fusion = self.fusion_model.predict(self.X_test_fusion)
        y_proba_fusion = self.fusion_model.predict_proba(self.X_test_fusion)[:, 1]
        acc_fusion = accuracy_score(self.y_test, y_pred_fusion)
        prec_fusion = precision_score(self.y_test, y_pred_fusion)
        rec_fusion = recall_score(self.y_test, y_pred_fusion)
        f1_fusion = f1_score(self.y_test, y_pred_fusion)
        fpr_fusion, tpr_fusion, _ = roc_curve(self.y_test, y_proba_fusion)
        auc_fusion = auc(fpr_fusion, tpr_fusion)
        cm_fusion = confusion_matrix(self.y_test, y_pred_fusion)

        # Calculate metrics for Baseline model (SIFT only)
        # Assuming SIFT features are the first 128 dimensions (adjust if your SIFT output differs)
        X_test_sift = self.X_test_fusion[:, :128]

        # Check if the baseline model expects a certain number of features
        # If it was trained on only 128 (SIFT) features, this is fine.
        # If it was trained on more (e.g. SIFT + LBP), then you would need to adjust the slice.
        try:
            y_pred_base = self.baseline_model.predict(X_test_sift)
            y_proba_base = self.baseline_model.predict_proba(X_test_sift)[:, 1]
            acc_base = accuracy_score(self.y_test, y_pred_base)
            prec_base = precision_score(self.y_test, y_pred_base)
            rec_base = recall_score(self.y_test, y_pred_base)
            f1_base = f1_score(self.y_test, y_pred_base)
            fpr_base, tpr_base, _ = roc_curve(self.y_test, y_proba_base)
            auc_base = auc(fpr_base, tpr_base)
            cm_base = confusion_matrix(self.y_test, y_pred_base)
        except Exception as e:
            messagebox.showwarning("Baseline Model Error", f"Could not evaluate baseline model: {e}. Ensure baseline_sift_xgboost_model.pkl is trained on SIFT features only.")
            # Fallback to dummy data for baseline if error occurs
            acc_base, prec_base, rec_base, f1_base = 0.5, 0.5, 0.5, 0.5
            fpr_base, tpr_base = [0, 0.5, 1], [0, 0.5, 1]
            auc_base = 0.5
            cm_base = np.array([[50, 50], [50, 50]]) # A random confusion matrix

        # Fill table with real values
        self.perf_table.insert('', tk.END, values=(
            'Fusion (SIFT+DeepFeat+GAN)', f'{acc_fusion:.2f}', f'{prec_fusion:.2f}', f'{rec_fusion:.2f}', f'{f1_fusion:.2f}'))
        self.perf_table.insert('', tk.END, values=(
            'Baseline (SIFT Only)', f'{acc_base:.2f}', f'{prec_base:.2f}', f'{rec_base:.2f}', f'{f1_base:.2f}'))

        # Plot ROC and confusion matrices using the real data
        self.show_roc_curve(roc_frame, fpr_fusion, tpr_fusion, auc_fusion, fpr_base, tpr_base, auc_base)
        self.show_confusion_matrix(cm_fusion, cm_fusion_frame, 'Fusion (SIFT+DeepFeat+GAN)')
        self.show_confusion_matrix(cm_base, cm_base_frame, 'Baseline (SIFT Only)')

    def show_roc_curve(self, frame, fpr1, tpr1, auc1, fpr2, tpr2, auc2):
        # Clear previous plot if any
        for widget in frame.winfo_children():
            if isinstance(widget, tk.Canvas):
                widget.destroy()

        fig = plt.Figure(figsize=(3.5, 2.5), dpi=100)
        ax = fig.add_subplot(111)
        ax.plot(fpr1, tpr1, label=f'Fusion (AUC={auc1:.2f})')
        ax.plot(fpr2, tpr2, label=f'Baseline (AUC={auc2:.2f})')
        ax.plot([0, 1], [0, 1], 'k--', lw=1)
        ax.set_xlabel('False Positive Rate')
        ax.set_ylabel('True Positive Rate')
        ax.set_title('ROC Curve')
        ax.legend(loc='lower right')
        fig.tight_layout()
        canvas = FigureCanvasTkAgg(fig, master=frame)
        canvas.draw()
        canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

    def show_confusion_matrix(self, cm, frame, model_name):
        # Clear previous plot if any
        for widget in frame.winfo_children():
            if isinstance(widget, tk.Canvas):
                widget.destroy()

        fig = plt.Figure(figsize=(2.5, 2.5), dpi=100)
        ax = fig.add_subplot(111)
        cax = ax.matshow(cm, cmap='Blues')
        for (i, j), z in np.ndenumerate(cm):
            ax.text(j, i, f'{z}', ha='center', va='center', color='black', fontsize=12)
        ax.set_xlabel('Predicted')
        ax.set_ylabel('Actual')
        ax.set_xticks([0, 1])
        ax.set_yticks([0, 1])
        ax.set_xticklabels(['Real', 'Fake'])
        ax.set_yticklabels(['Real', 'Fake'])
        ax.set_title(f'Confusion Matrix: {model_name}')
        fig.colorbar(cax)
        fig.tight_layout()
        canvas = FigureCanvasTkAgg(fig, master=frame)
        canvas.draw()
        canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

    def select_image(self):
        """Handle image selection"""
        file_path = filedialog.askopenfilename(
            filetypes=[("Image files", "*.jpg *.jpeg *.png *.bmp *.gif")]
        )
        if file_path:
            self.selected_image_path = file_path
            self.display_image(file_path)
            self.analyze_image()  # Automatically analyze after upload
    
    def display_image(self, image_path):
        """Display the selected image"""
        try:
            # Load and resize image
            image = Image.open(image_path)
            image.thumbnail((200, 200))  # Resize for preview
            photo = ImageTk.PhotoImage(image)
            
            # Update preview
            self.image_preview.configure(image=photo)
            self.image_preview.image = photo  # Keep reference
            self.image_name_label.config(text=os.path.basename(image_path))
        except Exception as e:
            messagebox.showerror("Error", f"Failed to load image: {str(e)}")
    
    def analyze_image(self):
        """Analyze the selected image"""
        if not self.selected_image_path:
            messagebox.showwarning("Warning", "Please select an image first")
            return
        
        # Preprocess and extract features
        img_bgr = cv2.imread(self.selected_image_path) # Read as BGR for OpenCV
        if img_bgr is None:
            messagebox.showerror("Error", "Could not read image for analysis.")
            return
        features = self.feature_extractor.extract_all_features(img_bgr)
        features = features.reshape(1, -1) # Reshape for single prediction

        # Predict with fusion model
        proba = self.fusion_model.predict_proba(features)[0]
        confidence = max(proba)
        predicted_class_idx = np.argmax(proba) # Get index of predicted class
        # Assuming your model was trained with classes [0, 1] where 0=FAKE, 1=REAL
        verdict = "REAL" if predicted_class_idx == 1 else "FAKE"

        # Similarity (to mean feature vector of predicted class)
        try:
            if predicted_class_idx == 1:
                similarity = cosine_similarity(features, [self.mean_features_real])[0][0]
            else:
                similarity = cosine_similarity(features, [self.mean_features_fake])[0][0]
        except Exception as e:
            print(f"Error calculating similarity: {e}. Using dummy similarity.")
            similarity = 0.5 # Fallback to dummy if error

        self.show_analysis_results(verdict, confidence, similarity)
        self.show_visualizations(img_bgr) # Pass BGR image for consistent visualization
    
    def show_analysis_results(self, verdict, confidence, similarity):
        """Show analysis results"""
        self.results_text.config(state=tk.NORMAL)
        self.results_text.delete(1.0, tk.END)
        lines = [
            "Analysis Results:",
            f"Image: {os.path.basename(self.selected_image_path)}",
            f"Verdict: {verdict}",
            f"Confidence: {confidence*100:.2f}%",
            f"Similarity Score: {similarity*100:.2f}%"
        ]
        self.results_text.insert(tk.END, '\n'.join(lines))
        self.results_text.config(state=tk.DISABLED)
        # Update original image label with verdict/confidence
        self.viz_canvases[0].config(text=f"Original: {verdict} ({confidence*100:.2f}%)")
    
    def show_visualizations(self, img_bgr):
        """Show image visualizations"""
        # Clear previous plots in visualization frames
        for frame in [self.viz_canvases[2], self.viz_canvases[3]]: # Histogram and Edge detection frames
            for widget in frame.winfo_children():
                if isinstance(widget, tk.Canvas):
                    widget.destroy()

        # Original image
        image_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)
        pil_img = Image.fromarray(image_rgb)
        pil_img = pil_img.resize((200, 200))
        photo = ImageTk.PhotoImage(pil_img)
        self.viz_labels[0].configure(image=photo)
        self.viz_labels[0].image = photo

        # Preprocessed image (grayscale for visualization, consistent with feature extraction)
        gray = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2GRAY)
        pil_gray = Image.fromarray(gray).convert('RGB').resize((200, 200))
        photo_gray = ImageTk.PhotoImage(pil_gray)
        self.viz_labels[1].configure(image=photo_gray)
        self.viz_labels[1].image = photo_gray

        # Color histogram
        fig = plt.Figure(figsize=(2.5, 2), dpi=80)
        ax = fig.add_subplot(111)
        for i, color_char in enumerate(['b', 'g', 'r']):
            hist = cv2.calcHist([img_bgr], [i], None, [256], [0, 256])
            ax.plot(hist, color=color_char)
        ax.set_xlim([0, 256])
        ax.set_title('Color Histogram')
        ax.axis('off')
        canvas = FigureCanvasTkAgg(fig, master=self.viz_canvases[2])
        canvas.draw()
        canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

        # Edge detection
        edges = cv2.Canny(gray, 100, 200)
        pil_edges = Image.fromarray(edges).convert('RGB').resize((200, 200))
        photo_edges = ImageTk.PhotoImage(pil_edges)
        self.viz_labels[3].configure(image=photo_edges)
        self.viz_labels[3].image = photo_edges 